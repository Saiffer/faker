"use strict";var o=Object.defineProperty;var s=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var h=Object.prototype.hasOwnProperty;var d=(m,e)=>{for(var n in e)o(m,n,{get:e[n],enumerable:!0})},w=(m,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let t of x(e))!h.call(m,t)&&t!==n&&o(m,t,{get:()=>e[t],enumerable:!(r=s(e,t))||r.enumerable});return m};var M=m=>w(o({},"__esModule",{value:!0}),m);var I={};d(I,{NumberModule:()=>y});module.exports=M(I);var a=require("../../errors/faker-error"),g=require("../../internal/deprecated"),c=require("../../internal/module-base");class y extends c.SimpleModuleBase{int(e={}){typeof e=="number"&&(e={max:e});const{min:n=0,max:r=Number.MAX_SAFE_INTEGER}=e,t=Math.ceil(n),i=Math.floor(r);if(t===i)return t;if(i<t)throw r>=n?new a.FakerError(`No integer value between ${n} and ${r} found.`):new a.FakerError(`Max ${r} should be greater than min ${n}.`);const u=this.faker._randomizer.next();return Math.floor(u*(i+1-t)+t)}float(e={}){typeof e=="number"&&(e={max:e});const{min:n=0,max:r=1,precision:t,multipleOf:i=t}=e;if(t!==void 0&&(0,g.deprecated)({deprecated:"faker.number.float({ precision })",proposed:"faker.number.float({ multipleOf })",since:"8.4",until:"9.0"}),r===n)return n;if(r<n)throw new a.FakerError(`Max ${r} should be greater than min ${n}.`);if(i!==void 0){if(i<=0)throw new a.FakerError("multipleOf/precision should be greater than 0.");const l=Math.log10(i),b=i<1&&Number.isInteger(l)?10**-l:1/i;return this.int({min:n*b,max:r*b})/b}return this.faker._randomizer.next()*(r-n)+n}binary(e={}){typeof e=="number"&&(e={max:e});const{min:n=0,max:r=1}=e;return this.int({max:r,min:n}).toString(2)}octal(e={}){typeof e=="number"&&(e={max:e});const{min:n=0,max:r=7}=e;return this.int({max:r,min:n}).toString(8)}hex(e={}){typeof e=="number"&&(e={max:e});const{min:n=0,max:r=15}=e;return this.int({max:r,min:n}).toString(16)}bigInt(e={}){var f,u;(typeof e=="bigint"||typeof e=="number"||typeof e=="string"||typeof e=="boolean")&&(e={max:e});const n=BigInt((f=e.min)!=null?f:0),r=BigInt((u=e.max)!=null?u:n+BigInt(999999999999999));if(r===n)return n;if(r<n)throw new a.FakerError(`Max ${r} should be larger then min ${n}.`);const t=r-n,i=BigInt(this.faker.string.numeric({length:t.toString(10).length,allowLeadingZeros:!0}))%(t+BigInt(1));return n+i}}0&&(module.exports={NumberModule});
